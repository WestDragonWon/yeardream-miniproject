---
apiVersion: v1 # Kubernetes API 버전 지정1
kind: PersistentVolume # 이 리소스가 PersistentVolume임을 명시
metadata:
  name: postgres-pv # PersistentVolume의 이름 지정
spec:
  capacity:
    storage: 1Gi # 스토리지 용량을 1 기가바이트로 설정
  volumeMode: Filesystem # 파일시스템 모드로 볼륨 사용 말그래도 모드를 설정하나봄 ..
  accessModes:
    - ReadWriteMany # 여러 노드에서 읽기/쓰기 가능하도록 설정 ReadWriteOnece는 하나에서만 가능하다. 다른 노드에서 접근이 불가능함. 동시 쓰기가 불가능.
  persistentVolumeReclaimPolicy: Retain # PV 삭제 시 데이터 유지 # Delete로 설정하면 데이터 삭제
  storageClassName: efs-sc # EFS 스토리지 클래스 사용
  csi:
    driver: efs.csi.aws.com # AWS EFS CSI 드라이버 사용
    volumeHandle: fs-00fb81d888c7ed27c # 특정 EFS 볼륨 지정
    #AWS EFS CSI 드라이버에서 사용되는 EFS 파일 시스템 ID (여기서는 fs-00fb81d888c7ed27c)는 AWS 콘솔이나 AWS CLI를 통해 확인할 수 있다 > 일반 계정으로는 확인 불가능 한듯. 

---
apiVersion: v1 # Kubernetes API 버전 지정
kind: PersistentVolumeClaim # 이 리소스가 PersistentVolumeClaim임을 명시 #관련 사담 : 꿈을 꿨는데 PVC라는 주식이 만원까지 올랐음.
metadata:
  name: postgres-pvc # PersistentVolumeClaim의 이름 지정
spec:
  accessModes:
    - ReadWriteMany # 여러 노드에서 읽기/쓰기 가능하도록 설정 
  storageClassName: efs-sc # EFS 스토리지 클래스 사용
  resources:
    requests:
      storage: 1Gi # 1 기가바이트의 스토리지 요청
#PV와 PVC는 도서관과 도서보관신청서 ..? PV는 관리자가 준비하고 관리하며 이용자는 신청서를 작성하여 어느정도의 보관(공간 및 구성)을 명시하고 PV가 적정한 책장을 찾아 할당함 ..
#PV는 사용 가능한 저장 공간이고, PVC는 그 공간을 사용하기 위한 요청. 이 시스템을 통해 사용자는 복잡한 저장소 세부사항을 몰라도 필요한 저장 공간을 쉽게 사용할수 있게함.. 우리는 도서관 전체를 요청..

---
apiVersion: apps/v1 # Kubernetes apps API 버전 지정
kind: StatefulSet # 이 리소스가 StatefulSet임을 명시 * Deployment가 아닌 Statefulset을 사용하는 이유는 모든 복제본에 대한 볼륨을 생성 * 데이터 백업에서 중요한 기능이라고 생각됨.. 사견임
metadata:
  name: postgres # StatefulSet의 이름 지정
spec:
  serviceName: "postgres" # 연관된 서비스 이름 지정
  replicas: 1 # Pod 복제본 수를 2개로 설정 () *-0.-1로 복제. 각각 pod 구성 후 복제 정상 작동 여부 시도시 postgre 강제 종료 및 CrashloopBackoff 발생. 데이터 초기화 불가능으로 POD 초기화함.
  selector:
    matchLabels:
      app: postgres # 이 라벨을 가진 Pod 선택
  template:
    metadata:
      labels:
        app: postgres # Pod에 적용할 라벨 지정
    spec:
      containers:
      - name: postgres # 컨테이너 이름 지정
        image: postgres:13 # PostgreSQL 13 버전 이미지 사용 * latest 또는 중간 것 사용?
        ports:
        - containerPort: 5432 # PostgreSQL 기본 포트 노출
        envFrom:
        - secretRef:
            name: db # 'db'라는 이름의 Secret에서 환경 변수 가져오기 * 클러스터 구성 및 Postgre 접속시 여러 환경변수를 사용하니 이것 말도고 많이 필요한거같다. 
        volumeMounts:
        - name: postgres-storage # 마운트할 볼륨 이름
          mountPath: /var/lib/postgresql/data_temp # 컨테이너 내 마운트 경로 ★ 관련해서 이슈가 많았고 제대로 해결하지 못했다 .. 이게 뭐라고 ..
# PostgreSQL는 데이터 디렉토리가 비어있지 않으면 새로운 데이터 베이스 클러스터 초기화하지않음(일종의 안전장치). data 폴더가 뭔가 있는상태로 지우고 재지정 하면 될듯.
# data_temp로 경로를 새로 지정하고 data 폴더 확인 결과 이미 초기화가 된 상태. 해당 디렉토리를 완전히 삭제 후 기존 리소스를 삭제해야 폴더 지정이 다시 될듯 하다. 보류 ..
# 클러스터 구성 전 yaml로 백업 .. 경로 문제때문에 다시 안될 수 도 있다 .. 경로는 이전 사용 경로였는데 문제없이 running 됨 ..
# 일단 경로 data로 다시 지정해보고 클러스터 구성 시도 > data 쪽은 뭔가 막힌 듯 바로 crashloopbackoff 뜸 .. > data_temp로 임시경로 지정 > data 기본경로상 문제가 있는 것 같다.
# spec.persistentVolumeReclaimPolicy: Retain 이라서 기존 데이터때문에 초기화가 안되는건지? 권한문제? (EFS? 이건 권한 받은건데 ..)
# 999라는 데이터폴더 생성 권한이 필요하다. data는 기본 경로 이므로..
        resources:
          requests:
            cpu: 500m # 최소 0.5 CPU 코어 요청
            memory: 1Gi # 최소 1 기가바이트 메모리 요청
          limits:
            cpu: 1 # 최대 1 CPU 코어 사용 제한
            memory: 2Gi # 최대 2 기가바이트 메모리 사용 제한
      volumes:
      - name: postgres-storage # 볼륨 이름 지정
        persistentVolumeClaim:
          claimName: postgres-pvc # 사용할 PVC 이름 지정
          
---
apiVersion: v1 # Kubernetes API 버전 지정
kind: Service # 이 리소스가 Service임을 명시
metadata:
  name: postgres # 서비스 이름 지정
spec:
  selector:
    app: postgres # 이 라벨을 가진 Pod 선택
  ports:
    - protocol: TCP # TCP 프로토콜 사용
      port: 5432 # 서비스 포트
      targetPort: 5432 # 대상 Pod의 포트
  clusterIP: None  # Headless 서비스로 설정 (StatefulSet용) 각 데이터베이스 노드에 직접 접근해야하는 경우 사용한다고 함.
